schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @extends on OBJECT | INTERFACE

directive @external on FIELD_DEFINITION

interface Paginated {
  pagination: Pagination!
}

type AgentAuthentication {
  token: String!
}

type AgentEvent {
  authentication: AgentAuthentication
  scrape: ScrapeRequest
}

type Authentication {
  corrId: ID!
  token: String!
}

type AuthenticationEvent {
  authentication: Authentication
  confirmCode: ConfirmCode
}

type ConfirmCode {
  length: Int!
  otpId: ID!
}

type Enclosure {
  duration: Long
  size: Long
  type: String!
  url: String!
}

type Feature {
  name: String!
  value: FeatureValue!
}

type FeatureBooleanValue {
  value: Boolean!
}

type FeatureIntValue {
  value: Int!
}

type FeatureValue {
  boolVal: FeatureBooleanValue
  numVal: FeatureIntValue
}

type Activity {
  items: [ActivityItem!]!
}

type ActivityItem {
  count: Int!
  index: String!
}

type Repository {
  id: ID!
  description: String!
  title: String!
  ownerId: ID!
  visibility: Visibility!
  refreshCron: String!
  sunset: SunSetPolicy
  createdAt: Long!
  lastUpdatedAt: Long!
  nextUpdateAt: Long
  documentCount: Long!
  documentCountSinceCreation: Long!
  disabledFrom: Long
  archived: Boolean!
  activity: Activity!
  plugins: [PluginExecution!]!
  segmented: Segment
  retention: Retention!
  sources: [ScrapeRequest!]!
}

type SunSetPolicy {
  afterTimestamp: Long
  afterSnapshots: Int
}

type LoginResponse {
  token: String!
  user: User!
}

type Mutation {
  authAnonymous: Authentication!
  authConfirmCode(data: ConfirmAuthCodeInput!): Boolean!
  createStory(data: CreateStoryInput!): Story!
  createComment(data: CreateCommentInput!): Comment!
  createVote(data: CreateVoteInput!): Vote!
  deleteVote(data: DeleteVoteInput!): Boolean!

  authUser(data: AuthUserInput!): Authentication!
  createUser(data: CreateUserInput!): User!
  createUserSecret: UserSecret!
  deleteUserSecrets(data: DeleteUserSecretsInput!): Boolean!

  createRepositories(data: RepositoriesCreateInput!): [Repository!]!
  updateRepository(data: RepositoryUpdateInput!): Repository!
  deleteRepository(data: RepositoryUniqueWhereInput!): Boolean!

  logout: Boolean
  submitAgentData(data: SubmitAgentDataInput!): Boolean!
  updateCurrentUser(data: UpdateCurrentUserInput!): Boolean!
  updateLicense(data: UpdateLicenseInput!): License!

  createWebDocuments(data: [CreateWebDocumentInput!]!): [WebDocument!]!
#  updateWebDocument(data: UpdateWebDocumentInput!): Boolean!
  deleteWebDocument(data: DeleteWebDocumentInput!): Boolean!
}

input DeleteVoteInput {
  where: EntityUniqueWhere!
}

input CreateVoteInput {
  where: StoryOrCommentWhereInput!
  vote: VoteInput!
}

input StoryOrCommentWhereInput {
  story: EntityUniqueWhere
  comment: EntityUniqueWhere
}

input EntityUniqueWhere {
  id: ID!
}

input VoteInput {
  upVote: Boolean
  downVote: Boolean
  downFlag: Boolean
}

type Vote {
  upVote: Boolean!
  downVote: Boolean!
  downFlag: Boolean!
}

input CreateStoryInput {
  title: String!
  link: String!
  content: String!
}

type Story {
  id: ID!
  content: String!
  title: String!
  link: String!
  dead: Boolean!
  flagged: Boolean!
  publishedAt: Long!
  score: Float!
  comments: [Comment!]!
}

input CreateCommentInput {
  data: String!
  commentId: ID!
}

type Comment {
  id: ID!
  content: String!
  dead: Boolean!
  flagged: Boolean!
  score: Float!
  publishedAt: Long!
  comments: [Comment!]!
}

input UpdateLicenseInput {
  licenseRaw: String!
}

input RepositoryUpdateInput {
  where: RepositoryUniqueWhereInput!
  data: UpdateSinkOptionsDataInput!
}

input UpdateSinkOptionsDataInput {
  sinkOptions: UpdateSinkOptionsInput
  sources: SourcesUpdateInput
}

input SourcesUpdateInput {
  remove: [ID!]
  add: [ScrapeRequestInput!]
}

input UpdateSinkOptionsInput {
  description: NullableStringUpdateOperationsInput
  refreshCron: NullableStringUpdateOperationsInput
  title: StringUpdateOperationsInput
  visibility: VisibilityUpdateOperationsInput
  retention: RetentionUpdateInput
  plugins: [PluginExecutionInput!]
}

input RetentionUpdateInput {
  maxItems: NullableIntUpdateOperationsInput
  maxAgeDays: NullableIntUpdateOperationsInput
}


input CreateWebDocumentInput {
  contentRawBase64: String
  contentRawMime: String
  contentText: String
  contentTitle: String!
  createdAt: Long!
  updatedAt: Long
  url: String!
}

input DeleteWebDocumentInput {
  where: WebDocumentUniqueWhereInput!
}

input UpdateWebDocumentInput {
  where: WebDocumentUniqueWhereInput!
  data: WebDocumentInput!
}

input WebDocumentInput {
  contentRawBase64: NullableStringUpdateOperationsInput
  contentRawMime: NullableStringUpdateOperationsInput
  contentText: StringUpdateOperationsInput
  contentTitle: StringUpdateOperationsInput
}

input CreateUserInput {
  email: String!
  product: ProductName!
  plan: PlanName!
  newsletter: Boolean!
}

enum ProductName {
  rssBuilder
  visualDiff
  reader
  feedless

#  shouldWeLaunchThis
#  automatedBrowser
#  feedAnanlytics
#  communityThreads
#  teamDraft
  upcoming
  untoldNotes
  pageChangeTracker
  digest
  featureFlags
  feedDump
#  openRoadmap
#  commentOn
}

type Agent {
  secretKeyId: ID!
  ownerId: ID!
  version: String!
  addedAt: Long!
  openInstance: Boolean!
}

type Pagination {
  isEmpty: Boolean!
  isFirst: Boolean!
  isLast: Boolean!
  page: Int!
  pageSize: Int!
}

type Plan {
  id: ID!
  name: PlanName!
  availability: PlanAvailability!
  currentCosts: Float!
  beforeCosts: Float
  parent: Plan
  features: [Feature!]!
}

type PlanSubscription {
  expiry: Long
  plan: Plan!
  planId: ID!
  startedAt: Long!
}

type Plugin {
  id: ID!
  name: String!
  type: PluginType!
  listed: Boolean!
#  params: PluginParamsSchema
}

#type PluginParamsSchema {
#  schema: String!
#}

enum PluginType {
  entity
  fragment
}

type Session {
  isAnonymous: Boolean!
  isLoggedIn: Boolean!
  user: User
  userId: ID
}

type Query {
  agents: [Agent!]!
  plugins: [Plugin!]!

  stories(data: StoriesWhereInput!): [Story!]!

  repository(data: RepositoryWhereInput!): Repository!
  repositories(data: RepositoriesInput!): [Repository!]!

  scrape(data: ScrapeRequestInput!): ScrapeResponse!
  plans(product: ProductName!): [Plan!]!
  session: Session!

  remoteNativeFeed(data: RemoteNativeFeedInput!): RemoteNativeFeed!
  previewFeed(data: PreviewFeedInput!): RemoteNativeFeed!

  serverSettings(data: ServerSettingsContextInput!): ServerSettings!
  license: License!

  webDocument(data: WebDocumentWhereInput!): WebDocument!
  webDocuments(data: WebDocumentsInput!): [WebDocument!]!
}

input StoriesWhereInput {
  best: Boolean!
  newest: Boolean!
}

input PreviewFeedInput {
  requests: [ScrapeRequestInput!]!
  filters: [CompositeFilterParamsInput!]!
}

input WebDocumentsInput {
  cursor: Cursor!
  where: WebDocumentsWhereInput
}

input WebDocumentsWhereInput {
  repository: RepositoryWhereInput!
  updatedAt: DatesWhereInput
}

input DatesWhereInput {
  after: DateWhereInput!
}

input DateWhereInput {
  value: DateTime!
}

input ServerSettingsContextInput {
  host: String!
  product: ProductName!
}

type RefineOptions {
  filter: String
}

type RemoteNativeFeed {
  expired: Boolean!
  feedUrl: String!
  publishedAt: Long!
  title: String!
  author: String
  description: String
  items: [WebDocument!]
  language: String
  websiteUrl: String
}

type RequestHeader {
  name: String
  value: String
}

input RequestHeaderInput {
  name: String
  value: String
}

type ScrapePage {
  timeout: Int
  url: String!
  prerender: ScrapePrerender
  actions: [ScrapeAction!]
}

type ScrapeAction {
  click: DOMElement
  type: DOMActionType
  wait: WaitAction
  select: DOMActionSelect
  header: RequestHeader
  purge: DOMElementByXPath
}

input ScrapeActionInput {
  click: DOMElementInput
  purge: DOMElementByXPathInput
  type: DOMActionTypeInput
  wait: WaitActionInput
  select: DOMActionSelectInput
  header: RequestHeaderInput
}

type DOMElement {
  element: DOMElementByNameOrXPath
  position: XYPosition
}

type XYPosition {
  x: Int!
  y: Int!
}

type WaitAction {
  element: DOMElementByNameOrXPath!
}
input WaitActionInput {
  element: DOMElementByNameOrXPathInput!
}

input DOMElementInput {
  element: DOMElementByNameOrXPathInput
  position: XYPositionInput
}

input XYPositionInput {
  x: Int!
  y: Int!
}

type DOMActionType {
  element: DOMElementByXPath!
  typeValue: String!
}
input DOMActionTypeInput {
  element: DOMElementByXPathInput!
  typeValue: String!
}

type DOMActionSelect {
  element: DOMElementByXPath!
  selectValue: String!
}
input DOMActionSelectInput {
  element: DOMElementByXPathInput!
  selectValue: String!
}

type DOMElementByNameOrXPath {
  name: DOMElementByName
  xpath: DOMElementByXPath
}
input DOMElementByNameOrXPathInput {
  name: DOMElementByNameInput
  xpath: DOMElementByXPathInput
}

type DOMElementByXPath {
  value: String!
}
input DOMElementByXPathInput {
  value: String!
}

type DOMElementByName {
  value: String!
}
input DOMElementByNameInput {
  value: String!
}

input ScrapePageInput {
  timeout: Int
  url: String!
  prerender: ScrapePrerenderInput
  actions: [ScrapeActionInput!]
}

type ScrapePrerender {
  viewport: ViewPort
  language: String
  waitUntil: PuppeteerWaitUntil
  additionalWaitSec: Int!
}

input ScrapePrerenderInput {
  viewport: ViewPortInput
  language: String
  additionalWaitSec: Int
  waitUntil: PuppeteerWaitUntil
  agents: [AgentInput!]
}

input AgentInput {
  secretKeyId: ID!
}

type ViewPort {
  width: Int!
  height: Int!
  isMobile: Boolean!
  isLandscape: Boolean
}

input ViewPortInput {
  width: Int!
  height: Int!
  isMobile: Boolean!
  isLandscape: Boolean
}

type ScrapeDebugOptions {
  screenshot: Boolean
  console: Boolean
  network: Boolean
  cookies: Boolean
  html: Boolean
}

input ScrapeDebugOptionsInput {
  screenshot: Boolean
  console: Boolean
  network: Boolean
  cookies: Boolean
  html: Boolean
}

type ScrapeDebugTimes {
  render: Int!
  queue: Int!
}

input ScrapeDebugTimesInput {
  render: Int!
  queue: Int!
}

type ScrapeDebugResponse {
  corrId: String!
  screenshot: String
  prerendered: Boolean!
  console: [String!]!
  network: [NetworkRequest!]!
  cookies: [String!]
  html: String
  statusCode: Int
  contentType: String
  viewport: ViewPort
  metrics: ScrapeDebugTimes!
}

input ScrapeDebugResponseInput {
  corrId: String!
  screenshot: String
  prerendered: Boolean!
  console: [String!]!
  network: [NetworkRequestInput!]!
  cookies: [String!]
  html: String
  statusCode: Int
  contentType: String
  viewport: ViewPortInput
  metrics: ScrapeDebugTimesInput!
}

type NetworkRequest {
  url: String
  requestHeaders: String
  requestPostData: String
  responseHeaders: String
  responseSize: Int
  responseBody: String
}

input NetworkRequestInput {
  url: String
  requestHeaders: String
  requestPostData: String
  responseHeaders: String
  responseSize: Int
  responseBody: String
}

type Segment {
  digest: Boolean!
  size: Int!
  sortAsc: Boolean!
  sortBy: String!
}

type Selectors {
  contextXPath: String!
  dateIsStartOfEvent: Boolean!
  dateXPath: String!
  extendContext: ExtendContentOptions!
  linkXPath: String!
}

type ServerSettings {
  gatewayUrl: String!
  appUrl: String!
  buildFrom: Long!
  version: String!
  features: [Feature!]!
  profiles: [ProfileName!]!
}

type License {
  isValid: Boolean!
  isLocated: Boolean!
  isTrial: Boolean!
  trialUntil: Long
  data: LicenseData
}

type LicenseData {
  name: String!
  email: String!
  scope: String!
  version: Int!
  createdAt: Long!
}

type Subscription {
  authViaMail(data: AuthViaMailInput!): AuthenticationEvent!
  registerAgent(data: RegisterAgentInput!): AgentEvent!
  agents: [Agent!]!
}

input AuthViaMailInput {
  email: String!
  token: String!
  product: ProductName!
  osInfo: String!
  allowCreate: Boolean!
}

type TransientGenericFeed {
  count: Int
  feedUrl: String!
  hash: String!
  samples: [WebDocument!]!
  score: Float!
  selectors: Selectors!
}

type NativeFeed {
  autoRelease: Boolean!
  createdAt: Long!
  description: String
  domain: String
  errorMessage: String
  feedUrl: String!
  harvestRateFixed: Boolean!
  harvestRateMinutes: Int
  iconUrl: String
  imageUrl: String
  lastChangedAt: Long
  lastCheckedAt: Long
  lat: Long
  lon: Long
  ownerId: ID!
  status: NativeFeedStatus!
  streamId: ID!
  title: String!
  "  nextRefreshAt: Long"
  visibility: Visibility!
  websiteUrl: String
}

type User {
  hasAcceptedTerms: Boolean!
  createdAt: Long!
  email: String!
  id: ID!
  purgeScheduledFor: Long
  secrets: [UserSecret!]!
  subscription: PlanSubscription
  subscriptionId: ID
}

type UserSecret {
  id: ID!
  lastUsed: Long
  type: UserSecretType!
  validUntil: Long
  value: String!
  valueMasked: Boolean!
}

type WebDocument {
  contentRawBase64: String
  contentRawMime: String
  contentHtml: String
  contentText: String
  contentTitle: String
  createdAt: Long!
  enclosures: [Enclosure!]
  id: ID!
  imageUrl: String
  publishedAt: Long!
  startingAt: Long
  updatedAt: Long
  url: String!
}

type ScrapedElementMeta {
  favicon: String
  htmlBody: String
  imageUrl: String
  title: String
  description: String
  mimeType: String
  language: String
  url: String
}

enum ExtendContentOptions {
  NEXT
  NONE
  PREVIOUS
  PREVIOUS_AND_NEXT
}

enum ProfileName {
  authSSO
  authMail
  selfHosted
}
enum FeatureName {
  canCreateUser
  hasWaitList
  canSignUp
  canLogin
  canCreateAsAnonymous

  rateLimit
  minRefreshRateInMinutes
  publicScrapeSource

  scrapeRequestTimeout
  scrapeSourceRetentionMaxItems
  itemEmailForward
  itemWebhookForward
  api
  plugins
  scrapeSourceExpiryInDays
  scrapeSourceMaxCountActive
  scrapeRequestMaxCountPerSource
  scrapeRequestActionMaxCount
  scrapeSourceMaxCountTotal
}

enum NativeFeedStatus {
  defective
  disabled
  never_fetched
  not_found
  ok
  service_unavailable
}

enum PlanAvailability {
  available
  by_request
  unavailable
}

enum PlanName {
  basic
  free
  waitlist
}

enum PuppeteerWaitUntil {
  domcontentloaded
  load
  networkidle0
  networkidle2
}

enum SortField {
  publishedAt
}

enum SortOrder {
  asc
  desc
}

enum UserSecretType {
  Jwt
  SecretKey
}

enum Visibility {
  isPrivate
  isPublic
}

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

"A JSON scalar"
scalar JSON

"A 64-bit signed integer"
scalar Long

input AuthUserInput {
  email: String!
  secretKey: String!
}

input BoolUpdateOperationsInput {
  set: Boolean!
}

input RetentionInput {
  maxItems: Int
  maxAgeDays: Int
}

type Retention {
  maxItems: Int
  maxAgeDays: Int
}

input WebhookCreateOrConnectInput {
  connect: WebhookUniqueWhereInput
  create: WebhookCreateInput
}

input WebhookCreateInput {
  url: String!
}

input WebhookOrEmailInput {
  webhook: WebhookCreateOrConnectInput
  email: String
}

input WebhookUniqueWhereInput {
  id: ID!
}

input RepositoriesInput {
  cursor: Cursor!
  orderBy: OrderByInput
  where: RepositoriesWhereInput
}

input RepositoriesWhereInput {
  pluginIds: [String!]
}

input ConfirmAuthCodeInput {
  code: String!
  otpId: ID!
}

input Cursor {
  page: Int!
  pageSize: Int
}

input DateFilter {
  gt: Long
  lt: Long
}

input DeleteUserSecretsInput {
  where: UserSecretWhereInput!
}

input BoundingBoxInput {
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

type BoundingBox {
  x: Int!
  y: Int!
  w: Int!
  h: Int!
}

input RepositoryWhereInput {
  where: RepositoryUniqueWhereInput!
}

input RepositoryUniqueWhereInput {
  id: ID!
}

input RepositoriesCreateInput {
  repositories: [RepositoryCreateInput!]!
}

input RepositoryCreateInput {
  product: ProductName!
  sources: [ScrapeRequestInput!]!
  sourceOptions: SourceOptionsInput
  sinkOptions: SinkOptionsInput!
  additionalSinks: [WebhookOrEmailInput!]
}

input SinkOptionsInput {
  segmented: SegmentInput
  title: String!
  description: String!
  retention: RetentionInput
  refreshCron: String
  sunset: SunSetPolicyInput
  visibility: Visibility
  plugins: [PluginExecutionInput!]
}

input SunSetPolicyInput {
  afterTimestamp: Long
  afterSnapshots: Int
}

enum StringFilterOperator {
  contains,
  matches,
  endsWith,
  startsWidth
}

enum NumberFilterOperator {
  gt,
  eq,
  lt
}

input SourceOptionsInput {
  refreshCron: String!
  agents: [AgentByGroup!]
}

input AgentByGroup {
  group: String!
}

input PluginExecutionInput {
  pluginId: ID!
  params: PluginExecutionParamsInput!
}

input NullableBoolUpdateOperationsInput {
  set: Boolean
}

input NullableIntUpdateOperationsInput {
  set: Int
}

input NullableLongUpdateOperationsInput {
  set: Long
}

input NullableStringArrayUpdateOperationsInput {
  set: [String!]
}

input NullableStringUpdateOperationsInput {
  set: String
}

input NullableUpdateOperationsInput {
  assignNull: Boolean!
}

input OrderByInput {
  createdAt: SortOrder
  title: SortOrder
}

input RegisterAgentInput {
  secretKey: SecretKey!
  os: OsInfo!
  version: String!
  connectionId: String!
}

input OsInfo {
  arch: String!
  platform: String!
}

input RemoteNativeFeedInput {
  nativeFeedUrl: String!
}

input ScheduledRefreshRate {
  expression: String!
}

type ScrapedFeeds {
  genericFeeds: [TransientGenericFeed!]!
  nativeFeeds: [NativeFeed!]
}

type ScrapedReadability {
  url: String
  imageUrl: String
  title: String
  contentText: String
  content: String
  contentMime: String
  faviconUrl: String
  date: String
}

input SecretKey {
  email: String!
  secretKey: String!
}

input SegmentInput {
  digest: Boolean!
  size: Int!
  orderAsc: Boolean!
  orderBy: String!
}

input SelectorsInput {
  contextXPath: String!
  dateIsStartOfEvent: Boolean
  dateXPath: String
  extendContext: ExtendContentOptions
  linkXPath: String!
}

input StringArrayFilter {
  every: [String!]
  some: [String!]
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
}

input StringUpdateOperationsInput {
  set: String!
}

input SubmitAgentDataInput {
  corrId: ID!
  jobId: ID!
  scrapeResponse: ScrapeResponseInput!
}

input UpdateCurrentUserInput {
  acceptedTermsAndServices: BoolUpdateOperationsInput
  purgeScheduledFor: NullableUpdateOperationsInput
  dateFormat: StringUpdateOperationsInput
  timeFormat: StringUpdateOperationsInput
}

input UserSecretCreateInput {
  type: UserSecretType!
}

input UserSecretWhereInput {
  in: [ID!]!
}

input VisibilityOneOfInput {
  oneOf: [Visibility!]!
}

input VisibilityUpdateOperationsInput {
  set: Visibility!
}

input WebDocumentUniqueWhereInput {
  id: ID!
}

input WebDocumentWhereInput {
  where: WebDocumentUniqueWhereInput!
}

type ScrapeResponse {
  failed: Boolean!
  errorMessage: String
  url: String!
  debug: ScrapeDebugResponse!
  elements: [ScrapedElement!]!
}

type ScrapedElement {
  image: ScrapedByBoundingBox
  selector: ScrapedBySelector
}

type ScrapedBySelector {
  xpath: DOMElementByXPath!
  html: TextData
  text: TextData
  pixel: Base64Data
  fields: [ScrapedField!]
}

type ScrapedField {
  name: String!
  xpath: DOMElementByXPath
  value: ScrapedFieldValue
}

type ScrapedFieldValue {
  one: ScrapedSingleFieldValue
  many: [ScrapedSingleFieldValue!]
  nested: [ScrapedField!]
}

type ScrapedSingleFieldValue {
  mimeType: String!
  data: String!
}

type ScrapedByBoundingBox {
  boundingBox: BoundingBox!
  data: Base64Data!
}

type JsonData {
  jsonSchema: String!
  jsonData: String!
}

type Base64Data {
  base64Data: String!
}

type TextData {
  mimeType: String!
  data: String!
}

input ScrapeRequestInput {
  corrId: ID
  id: ID
  page: ScrapePageInput!
  errornous: Boolean
  localized: LocalizedSourceInput
  tags: [String!]
  lastErrorMessage: String
  debug: ScrapeDebugOptionsInput
  emit: [ScrapeEmitInput!]!
}

input LocalizedSourceInput {
  lat: Long!
  lon: Long!
}

input ScrapeEmitInput {
  imageBased: ScrapeBoundingBoxInput
  selectorBased: ScrapeSelectorInput
}

input ScrapeBoundingBoxInput {
  boundingBox: BoundingBoxInput!
}

input ScrapeSelectorInput {
  xpath: DOMElementByXPathInput!
  min: Int
  max: Int
  expose: ScrapeSelectorExposeInput!
}

input ScrapeSelectorExposeInput {
  pixel: Boolean
  transformers: [PluginExecutionInput!]
  fields: [ScrapeSelectorExposeFieldInput!]
}

input PluginExecutionParamsInput {
  org_feedless_feed: SelectorsInput
  org_feedless_diff_email_forward: DiffEmailForwardParamsInput
  org_feedless_filter: [CompositeFilterParamsInput!]
  jsonData: String
  org_feedless_fulltext: FulltextPluginParamsInput
}

input CompositeFilterParamsInput {
  exclude: CompositeFieldFilterParamsInput
  include: CompositeFieldFilterParamsInput
}

input CompositeFieldFilterParamsInput {
  index: NumericalFilterParamsInput
  title: StringFilterParamsInput
  content: StringFilterParamsInput
  link: StringFilterParamsInput
}

input StringFilterParamsInput {
  operator: StringFilterOperator!
  value: String!
}

input NumericalFilterParamsInput {
  operator: NumberFilterOperator!
  value: Int!
}

input DiffEmailForwardParamsInput {
  nextItemMinIncrement: Float!
  compareBy: WebDocumentField!
  inlineLatestImage: Boolean
  inlinePreviousImage: Boolean
  inlineDiffImage: Boolean
}

input FulltextPluginParamsInput {
  readability: Boolean!
  inheritParams: Boolean!
}

enum FeedlessPlugins {
  org_feedless_feed
  org_feedless_feeds
  org_feedless_fulltext
  org_feedless_filter
  org_feedless_privacy
  org_feedless_detect_media
  org_feedless_diff_email_forward
  org_feedless_spawn_page_tracker
}

enum WebDocumentField {
  pixel
  text
  markup
}

input ScrapeSelectorExposeFieldInput {
  name: String!
  value: ScrapeSelectorExposeFieldValueInput
  nested: ScrapeSelectorExposeNestedFieldValueInput
  min: Int
  max: Int
}

input ScrapeSelectorExposeNestedFieldValueInput {
  fields: [ScrapeSelectorExposeFieldInput!]!
}

input ScrapeSelectorExposeFieldValueInput {
  html: ScrapeSelectorExposeFieldHtmlValueInput
  text: ScrapeSelectorExposeFieldTextValueInput
  set: String
}

input ScrapeSelectorExposeFieldTextValueInput {
  regex: String!
}

input ScrapeSelectorExposeFieldHtmlValueInput {
  xpath: DOMElementByXPathInput!
}

type ScrapeRequest {
  corrId: ID
  id: ID!
  page: ScrapePage!
  errornous: Boolean
  localized: LocalizedSource
  tags: [String!]
  lastErrorMessage: String
  debug: ScrapeDebugOptions
  emit: [ScrapeEmit!]!
}

type LocalizedSource {
  lat: Long!
  lon: Long!
}


type ScrapeEmit {
  imageBased: ScrapeBoundingBox
  selectorBased: ScrapeSelector
}

type ScrapeBoundingBox {
  boundingBox: BoundingBox!
}

type ScrapeSelector {
  xpath: DOMElementByXPath!
  min: Int
  max: Int
  expose: ScrapeSelectorExpose!
}

type ScrapeSelectorExpose {
  pixel: Boolean
  transformers: [PluginExecution!]
  fields: [ScrapeSelectorExposeField!]
}

type PluginExecution {
  pluginId: ID!
  params: PluginExecutionParams!
}

type PluginExecutionParams {
  org_feedless_feed: Selectors
  org_feedless_diff_email_forward: DiffEmailForwardParams
  org_feedless_filter: [CompositeFilterParams!]
  jsonData: String
  org_feedless_fulltext: FulltextPluginParams
}

type CompositeFilterParams {
  exclude: CompositeFieldFilterParams
  include: CompositeFieldFilterParams
}

type CompositeFieldFilterParams {
  index: NumericalFilterParams
  title: StringFilterParams
  content: StringFilterParams
  link: StringFilterParams
}

type StringFilterParams {
  operator: StringFilterOperator!
  value: String!
}

type NumericalFilterParams {
  operator: NumberFilterOperator!
  value: Int!
}


type DiffEmailForwardParams {
  nextItemMinIncrement: Float!
  compareBy: WebDocumentField!
  inlineLatestImage: Boolean
  inlineDiffImage: Boolean
  inlinePreviousImage: Boolean
}

type FulltextPluginParams {
  readability: Boolean!
  inheritParams: Boolean!
}

type ScrapeSelectorExposeField {
  name: String!
  value: ScrapeSelectorExposeFieldValue
  nested: ScrapeSelectorExposeNestedFieldValue
  min: Int
  max: Int
}

type ScrapeSelectorExposeNestedFieldValue {
  fields: [ScrapeSelectorExposeField!]!
}

type ScrapeSelectorExposeFieldValue {
  html: ScrapeSelectorExposeFieldHtmlValue
  text: ScrapeSelectorExposeFieldTextValue
  set: String
}

type ScrapeSelectorExposeFieldTextValue {
  regex: String!
}

type ScrapeSelectorExposeFieldHtmlValue {
  xpath: DOMElementByXPath!
}

input ScrapeResponseInput {
  failed: Boolean!
  errorMessage: String
  url: String!
  debug: ScrapeDebugResponseInput!
  elements: [ScrapedElementInput!]!
}

input ScrapedElementInput {
  image: ScrapedByBoundingBoxInput
  selector: ScrapedBySelectorInput
}

input ScrapedBySelectorInput {
  xpath: DOMElementByXPathInput!
  html: TextDataInput
  text: TextDataInput
  pixel: Base64DataInput
  fields: [ScrapedFieldInput!]
}

input ScrapedFieldInput {
  name: String!
  xpath: TextDataInput
  value: ScrapedFieldValueInput
}

input ScrapedFieldValueInput {
  one: ScrapedSingleFieldValueInput
  many: [ScrapedSingleFieldValueInput!]
  nested: [ScrapedFieldInput!]
}

input ScrapedSingleFieldValueInput {
  mimeType: String!
  data: String!
}

input ScrapedByBoundingBoxInput {
  boundingBox: BoundingBoxInput!
  data: Base64DataInput!
}

input JsonDataInput {
  jsonSchema: String!
  jsonData: String!
}

input Base64DataInput {
  base64Data: String!
}

input TextDataInput {
  data: String!
}
